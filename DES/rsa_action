#!/bin/bash
count=0
function string_to_dec()
{
  eval ch="$1"
  if [[ $ch = " " ]]; then
    echo 32
    exit
  fi

  bin=$(echo -n $ch | perl -pe '$_=unpack"B*"')
  echo $bin >>temp
  echo "$((2#$bin))"
}

function dec_to_string()
{
  echo $1-count=$count >>temp
  count=$(( $count+1 ))
  printf "\x$(printf %x $1)"
}


function calculate_prime_number()
{
  is_prime=false
  prime=-1

  while [ "$is_prime" = false ]
  do
    is_prime=true
    prime=$( shuf -i 1000000-9999999 -n 1 )
    half_prime=$(( $prime / 2 + 1 ))

    for (( i=2 ; i < $half_prime ; i++ ))
    do
      m=$(( $prime % $i ))
      if [[ $m -eq 0 ]]; then
        is_prime=false
        break
      fi
    done
  done

  echo $prime
}

function find_e()
{
  phi=$1
  e=2

  while [ $e -lt $phi ]
  do
    gcd=$(gcd $e $phi)
    if [[ $gcd -eq 1 ]]; then
      break
    else
      e=$(( $e + 1 ))
    fi
  done

  echo $e
}

function find_d()
{
  phi=$1
  e=$2
  found=false
  k=1
  d=$(( ($phi + 1) / $e))
  while [ "$found" = false ]
  do
    d_temp=$(( ($phi * $k) + 1))
    if [[ $(( $d_temp % $e )) -eq 0 ]]; then
      d=$(( $d_temp / $e ))
      found=true
    else
      k=$(( $k + 1 ))
    fi
  done

  echo $d
}

function gcd()
{
  e=$1
  phi=$2
  temp=-1

  while true
  do
    temp=$(( e % $phi))
    if [[ $temp -eq 0 ]]; then
      echo $phi
      break
    fi

    e=$phi;
    phi=$temp;
  done
}


function pow_mod()
{
  base=$1
  exp=$2
  n=$3

  result=1
  while [ $exp -gt 0 ]
  do
    if [[ $(( $exp % 2 )) -eq 1 ]];then
      result=$(( $(( $result * $base)) % $n))
    fi
    base=$(( $(( $base * $base )) % $n ))
    exp=$(( $exp / 2 ))
  done
  result=$(( $result % $n ))
  echo $result
}


function action_message_arr_char_by_char()
{
  e=$1
  n=$2
  m_arr=("$@")
  #unstting pow and mod params from s_box arry:
  unset m_arr[0]
  unset m_arr[1]
  m_arr=("${m_arr[@]}")

  for num in "${m_arr[@]}"
  do
    m_e_arr+=($(pow_mod $num $e $n))
  done

  echo "${m_e_arr[@]}"
}

#prime1=7075183
#prime2=2191951

prime1=11
prime2=17

: <<'COMMENT'
echo calculating first prime number
prime1=$( calculate_prime_number )
prime2=-1

echo calculating second prime number

is_dif=false
while [ "$is_dif" = false ]
do
  is_dif=true
  prime2=$( calculate_prime_number )
  if [[ $prime2 -eq $prime1 ]]; then
    is_dif=false
  fi
done
COMMENT

echo prime1=$prime1
echo prime2=$prime2

#e & n for private key
n=$(( $prime1 * $prime2 ))
echo n=$n

# Find the Totient of ProductOfPrime1Prime2
phi=$(( ($prime1 - 1) * ($prime2 - 1) ))
echo phi=$phi

#gcd
e=$(find_e $phi)
echo e=$e

#private key
d=$(find_d $phi $e)
echo d=$d

message="hi my name is linux"

#split message to array
i=0
while [ $i -lt ${#message} ]
do
  ch="${message:$i:1}"
  echo \"$ch\"
  message_arr[$i]=$(string_to_dec "\${ch}")
  i=$((i+1))
done

echo mes_arr=${message_arr[@]}

e_m_arr=$(action_message_arr_char_by_char $e $n ${message_arr[@]})
echo e_m_arr=${e_m_arr[@]}

d_m_arr=$(action_message_arr_char_by_char $d $n ${e_m_arr[@]})
echo d_m_arr=${d_m_arr[@]}

str=
for num in ${d_m_arr[@]}
do
  dec_to_string "${num}"
  #str+=$(dec_to_string "${num}")
done
echo

#echo d_arr=${d_arr[@]}
